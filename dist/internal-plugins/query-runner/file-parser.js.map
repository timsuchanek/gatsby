{"version":3,"sources":["../../../src/internal-plugins/query-runner/file-parser.js"],"names":["filePath","fileStr","ast","apiRunnerNode","filename","contents","transpiled","length","item","tmp","babylon","parse","sourceType","plugins","console","info","undefined","error","sourceFilename","e","log","parseToAst","file","text","queries","ExportNamedDeclaration","path","state","traverse","TaggedTemplateExpression","innerPath","gqlAst","getGraphQLTag","definitions","forEach","def","name","value","stripIndent","process","exit","push","findGraphQLTags","fs","require","crypto","Bluebird","readFileAsync","promisify","readFile","cache","FileParser","indexOf","hash","createHash","update","digest","astDefinitions","kind","message","files","documents","parseFile","doc","set"],"mappings":"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","file":"file-parser.js","sourcesContent":["// @flow\nconst fs = require(`fs`)\nconst crypto = require(`crypto`)\n\n// Traverse is a es6 module...\nimport traverse from \"babel-traverse\"\nconst babylon = require(`babylon`)\nconst Bluebird = require(`bluebird`)\nconst { stripIndent } = require(`common-tags`)\n\nconst apiRunnerNode = require(`../../utils/api-runner-node`)\nconst { getGraphQLTag } = require(`../../utils/babel-plugin-extract-graphql`)\n\nimport type { DocumentNode, DefinitionNode } from \"graphql\"\n\nconst readFileAsync = Bluebird.promisify(fs.readFile)\n\nasync function parseToAst(filePath, fileStr) {\n  let ast\n\n  // Preprocess and attempt to parse source; return an AST if we can, log an\n  // error if we can't.\n  const transpiled = await apiRunnerNode(`preprocessSource`, {\n    filename: filePath,\n    contents: fileStr,\n  })\n\n  if (transpiled.length) {\n    for (const item of transpiled) {\n      try {\n        const tmp = babylon.parse(item, {\n          sourceType: `module`,\n          plugins: [`*`],\n        })\n        ast = tmp\n        break\n      } catch (e) {\n        console.info(e)\n        continue\n      }\n    }\n    if (ast === undefined) {\n      console.error(`Failed to parse preprocessed file ${filePath}`)\n    }\n  } else {\n    try {\n      ast = babylon.parse(fileStr, {\n        sourceType: `module`,\n        sourceFilename: true,\n        plugins: [`*`],\n      })\n    } catch (e) {\n      console.log(`Failed to parse ${filePath}`)\n      console.log(e)\n    }\n  }\n\n  return ast\n}\n\nasync function findGraphQLTags(file, text): Promise<Array<DefinitionNode>> {\n  let ast = await parseToAst(file, text)\n  if (!ast) return []\n\n  let queries = []\n  traverse(ast, {\n    ExportNamedDeclaration(path, state) {\n      path.traverse({\n        TaggedTemplateExpression(innerPath) {\n          const gqlAst = getGraphQLTag(innerPath)\n          if (gqlAst) {\n            gqlAst.definitions.forEach(def => {\n              if (!def.name || !def.name.value) {\n                console.log(stripIndent`\n                  GraphQL definitions must be \"named\".\n                  The query with the missing name is in ${file}.\n                  To fix the query, add \"query MyQueryName\" to the start of your query.\n                  So instead of:\n                  {\n                    allMarkdownRemark {\n                      totalCount\n                    }\n                  }\n\n                  Do:\n\n                  query MyQueryName {\n                    allMarkdownRemark {\n                      totalCount\n                    }\n                  }\n                `)\n                process.exit(1)\n              }\n            })\n\n            queries.push(...gqlAst.definitions)\n          }\n        },\n      })\n    },\n  })\n  return queries\n}\n\nconst cache = {}\n\nexport default class FileParser {\n  async parseFile(file: string): Promise<?DocumentNode> {\n    const text = await readFileAsync(file, `utf8`)\n\n    if (text.indexOf(`graphql`) === -1) return null\n    const hash = crypto\n      .createHash(`md5`)\n      .update(file)\n      .update(text)\n      .digest(`hex`)\n\n    try {\n      let astDefinitions =\n        cache[hash] || (cache[hash] = await findGraphQLTags(file, text))\n\n      return astDefinitions.length\n        ? {\n            kind: `Document`,\n            definitions: astDefinitions,\n          }\n        : null\n    } catch (err) {\n      console.error(`Failed to parse GQL query from file: ${file}`)\n      console.error(err.message)\n      return null\n    }\n  }\n\n  async parseFiles(files: Array<string>): Promise<Map<string, DocumentNode>> {\n    const documents = new Map()\n    for (let file of files) {\n      const doc = await this.parseFile(file)\n\n      if (doc) documents.set(file, doc)\n    }\n\n    return documents\n  }\n}\n"]}